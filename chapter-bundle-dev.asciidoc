[[bundle-development]]
==  Bundle Development

{inall}


[[bundle-development-introduction]]
=== Introduction

{oss} and {pro} are built on top of the OSGi container http://karaf.apache.org/[Apache Karaf]. The supporting core
infrastructure, know as {platform}, provides a foundation for these editions. The functionality is encapsulated in
a number of OSGi bundles. Each edition is composed of a number of bundles, that provided the specific features.

Bundles can provide further functionality for the backend such as support for new repository formats, specific
behavior for components, new tasks, and any other additional functionality as well as new user interface
components and modifications. They can also group a number of these features together in one bundle.

This chapter provides a high level overview and information to begin developing your own bundles for the
{platform}, and specifically the {pro}.

If you work on any bundle development and required any help or assistance, please contact the development team:

* the https://groups.google.com/a/glists.sonatype.com/forum/?hl=en#!forum/nexus-users[users mailing list]
* the https://links.sonatype.com/products/nexus/community-chat[community chat channel]
* or via email to nexus-feedback@sonatype.com



[[bundle-development-installing]]
=== Installing Bundles

In order to have your features from your bundle available as part of the repository manager, the bundle needs to
be loaded by the OSGi container.

The default build assembles multiple bundles into features that form the foundation of {oss} and {pro}. A number
of these definitions can be found in https://github.com/sonatype/nexus-public/tree/master/assemblies/[the
assemblies] module. The supported distributions are defined in the modules `nexus-oss-feature` and
`nexus-pro-feature`, which are part of the internal codebase. 

An installation of the repository manager defines the feature it loads in `etc/org.sonatype.nexus.cfg` and
additional features can be declared to be loaded there. E.g. to add `my-custom-feature` to an {oss} installation
you can change to

----
nexus-features=nexus-oss-feature,my-custom-feature
----

The feature and 

TBD - document how to load a bundle via the karaf console probably, and where to put it so it is available there,
or should we just refer to the Karaf docs for now?


you can edit the config in etc/org.sonatype.nexus.cfg add your feature to nexus-features list




or you can manually add the feature via karaf conmmands, and it will remember those on reboot







throw the bundle into the deploy folder and laod it with karaf commands should work too



Reload Karaf Bundles
Nexus modules can be rebuilt and redeployed into the Karaf container from the local maven repository using some simple commands from the console. After rebuilding and installing a module already deployed to the karaf container, you can redeploy it with these steps, which includes restarting the container.
#change the repository location to the local maven repo
config:property-set -p org.ops4j.pax.url.mvn org.ops4j.pax.url.mvn.defaultRepositories "file:${user.home}/.m2/repository@id=system.repository@snapshots"
 
#find the bundle you want to update, i.e. org.sonatype.nexus.plugins.nexus-coreui-plugin
bundle:list | grep coreui
 
# 270 | Active   | 200 | 3.0.0.SNAPSHOT    | org.sonatype.nexus.plugins.nexus-coreui-plugin
 
#update in OSGi is a two-step process: first update your bundles, then call refresh to make sure bundles that import from them are wired to the new version
#often this refresh step is not required, but without it you might run into class-loading issues if the update leaves bundles wired to conflicting versions
bundle:update 270
bundle:refresh
  
#the preceding steps updated and restarted affected bundles, but as Nexus still has a largely monolithic lifecycle you need to restart the Nexus application
#to make sure it picks up and execute the new code - especially if that code is only used during startup
system:shutdown -f -r


[[bundle-development-overview]]
=== Bundle Development Overview

The preferred way to write bundles is to use Java as the implementation language and Apache Maven as the build
system. The https://github.com/sonatype/nexus-public[public code-base of {oss}] can be used as a starting point to
investigate existing bundles and their source code. The easiest way to create a new bundlep project is to replicate
a bundle with a similar functionality. Inspect the source code of bundles with similar functionality, and read the
JavaDoc documentation for the involved classes.

IMPORTANT: Knowledge of Apache Maven and Java are required for your bundle development efforts. OSGi-related
knowledge is highly relevant and beneficial.

To gain access to all the components needed for your bundle development, you have to proxy the Sonatype grid
repository with the URL:

----
https://repository.sonatype.org/content/groups/sonatype-public-grid/
----

Set up your project to include inheriting from the parent of all the {oss} bundles with the version you are
targeting as displayed in <<fig-nexus-plugins-parent>>.

[[fig-nexus-plugins-parent]]
.Inheriting from the nexus-plugins Parent
----
 <parent>
    <groupId>org.sonatype.nexus.plugins</groupId>
    <artifactId>nexus-plugins</artifactId>
    <version>3.0.0-SNAPSHOT</version>
  </parent>
---- 

WARNING: It is best to use the identical version of the parent as the {pro} instance on which you want to run your
bundle. When developing a bundle you are using large parts of internals, which are subject to change from one
version to another. This same logic applies to any dependencies as well.

A bundle Maven project creates a custom build output file in the form of an OSGi bundle. Enable this by changing
the packaging to `bundle`. In addition, you need to add the `karaf-maven-plugin` and any needed dependencies.
Inspect the `pom.xml` files for specific bundle in the `plugins` directory for further details.

These dependencies pull in a large number of transitive dependencies that expose {pro} functionality and other
libraries to your project.  Depending on the type of bundle and functionality you aim to create, additional
dependencies and other details can be added to this minimal project setup.  A large number of further classes is
available and can be used as part of your bundle development.

With the exception of interfaces and code that is required to be accessible from modules outside of the format
bundle, all code should be nested within an 'internal' directory that will be isolated by the OSGi runtime
container.

Once you have created your Maven project as described above, you can build the bundle with `mvn clean install`.

[[repo-format]]
=== Support for a New Repository Format

In this chapter we are going to examine the efforts required to implement support for a new repository format in
the {pro}. By default, the repository manager includes support for various repository formats including
`raw`-format, `maven2`-format and others.

When considering to implement support for a new repository format, it is important to get a good understanding of
the format itself as well as the tools and the community working with the format. It might even be necessary to
read and understand the source code of potential native, upstream implementations to support a format.

Following are a few questions that can provide some useful answers leading to a better understanding of the format
and necessary steps for implementation;

* What is this format all about?
* What tools (client/server) are involved?
* What communication is performed between client and server?
* Do any protocols or specifications exist?
* What authentication method needs to be supported by the repository manager?
* How can the repository manager authenticate against a proxied remote server?
* How does the concepts of components and assets used in {pro} map to the format?
* What is the best way to map the component identifier of name, version and group to the format?
* What format specific attributes should stored on components and  assets?
* Is it necessary to rewrite proxied metadata? E.g. proxied metadata contains absolute urls to proxied server that
we have to rewrite to point to repository manager.
* Are there any special features that should be considered?

To provide sufficient support for users, a new repository format needs to include a number of features:

- proxying components from remote repositories
- storing and managing components in a hosted repository
- exposing multiple repositories to users as a single repository group
- format-specific search criteria and the related search functionality

Depending on the specific of the repository format being implemented a number of other features have to be
provided or can optionally provide additional value to the user:

- any required tasks for maintenance of the repositories and their content
- client side tools to allow the standard tools to interact with the repositories on the repository manager
- custom features to display information about the repositories or their content in the user interface

The implementation of all these features for the `raw`-format can be found in the module
`plugins/nexus-repository-raw`. The `raw` format is a good example codebase to expose as it present the most
simplistic repository format.

The Maven repositry format as used by Apache Maven and many other tools is implemented in the
`plugins/nexus-repository-maven` module. It can serve as another, slightly more complex, example. Examining the
code base can be especially useful, if you know the Maven repository format.

==== Repository Types and Repository Recipe

For each repository format there should be 3 types: proxy, hosted and group. Generally start
with the proxy implementation as that informs exactly how a client interacts with the remote system we are
proxying.

Repository Recipe

Each Repository Type has a corresponding Recipe implementation. This is how the system configures the 'view' of a
Repository. It configures the facets that decorate the implementation, and matches up routes with appropriate
handlers. Some handlers are required for all repositories (Security Handler for instance) while others need to be
crafted to deal with the particulars of a Repository format (i.e. RawContentHandler). Routes are defined for each
url a given format client can interact with, and handlers extract any parameterization from the requests to
satisfy them appropriately. The Context class provides helpers for getting at details of the requests
(i.e. insisting that required parameters are present).

Facets

These decorate the Repository and provide additional functionality (i.e. RawProxyFacet). Attached facets can be
accessed through 'repository.getFacet(clazz)' calls, which will throw exceptions if the requested facet is not
configured.

Security

Each format plugin should extend RepositoryFormatSecurityConfigurationResource to provide security
configuration. Usually there's no need to do more than @Named this implementation, but it could be used to
enhance/change the plugin security rules as necessary.

Data Storage

The overall package is described as a Component, which is essentially just common metadata (name, version, etc)
and a parent for Assets. An Asset represents binary content of any type, usually a jar/zip and perhaps additional
files associated with the package (i.e. pom.xml for maven). Some metadata is automatically collected for Assets,
like checksums, while each format can also contribute its own specific metadata. This should be attached to the
Asset attributes in a Map named after the format, i.e. attributes.gem. Note that an asset should always have a
sha1 checksum, but certain formats may require other types of checksum and should extend the
Asset.attributes.checksum map as required to store these.

UI

UI bits required are fairly boilerplate and can generally be cut&pasted from existing content, along with
approriate naming updates. We do not yet have a mechanism for cleanly incorporating plugin UI content, so this
should be implemented in:
nexus-internal/plugins/nexus-coreui-plugin/src/main/resources/static/rapture/NX/coreui/view/repository/recipe. These
merely compose configuration for specific facets, which should be implemented in:
nexus-internal/plugins/nexus-coreui-plugin/src/main/resources/static/rapture/NX/coreui/view/repository/facet If a
given format requires any additional specific configuration, add a new facet configuration screen with the
required fields. They should all be mapped to the key/value map (called attributes) of the repository. i.e. for
the gems plugin, any gem specific configuration (if there is any?) would be mapped to
attributes.gem.fooConfigProperty. New format configurations need to be registered in the 'views' configuration of:
nexus-internal/plugins/nexus-coreui-plugin/src/main/resources/static/rapture/NX/coreui/controller/Repositories.js


==== Proxy Repository

TBD

==== Hosted Repository

TBD

==== Repository Group

TBD

==== Search Criteria and Indexes

TBD

==== Client Tools

TBD - separate section, example like bower resolver


====  User Interface Extensions

TBD - another separate section probably


==== Tasks

TBD - probably best to have a separate task only example chapter and link to it



=== Contributing Bundles

Ideally any new bundles created, yields significant benefits for the overall community of users. Sonatype encourages
contriubtion of such bundles to the upstream repository and is offering support and help for such efforts.

The minimum steps for such contributions are:

* Sign and submit a http://www.sonatype.org/SonatypeCLA.pdf[contributor license agreement] to Sonatype
* Create a pull request with the relevant changes to the https://github.com/sonatype/nexus-public[nexus-public
  repository]

In further collaboration we will decide upon next steps on a case-by-case basis and work with you to

* Create sufficient tests
* Provide access to upstream repositories
* Facilitate other infrastructure such as CI server builds
* Help you with verification and testing
* Work with you on user documentation and outreach
* Expose your work to the user community
* And many others.




